import 'package:flutter/material.dart';
import '../../data/repositories/product_repository.dart';
import '../../data/models/product_model.dart';
import 'dart:async';

class ProductProvider extends ChangeNotifier {
  final ProductRepository _productRepository;

  ProductProvider(this._productRepository) {
    _initConnectivityListener();
  }

  // States
  List<ProductModel> _products = [];
  List<ProductModel> _filteredProducts = [];
  bool _isLoading = false;
  bool _isLoadingMore = false;
  bool _isOffline = false; // üÜï Offline durumu
  String? _errorMessage;
  String? _selectedCategory;
  String _searchQuery = '';
  
  // Pagination
  int _currentPage = 1;
  final int _pageSize = 20;
  bool _hasMore = true;

  // Debounce timer for search
  Timer? _debounceTimer;
  
  // Connectivity listener
  StreamSubscription? _connectivitySubscription;

  // Getters
  List<ProductModel> get products => _filteredProducts.isEmpty && _searchQuery.isEmpty && _selectedCategory == null
      ? _products
      : _filteredProducts;
  bool get isLoading => _isLoading;
  bool get isLoadingMore => _isLoadingMore;
  bool get isOffline => _isOffline; // üÜï
  String? get errorMessage => _errorMessage;
  String? get selectedCategory => _selectedCategory;
  String get searchQuery => _searchQuery;
  bool get hasMore => _hasMore;
  int get productCount => products.length;

  // üÜï Connectivity listener
  void _initConnectivityListener() {
    // ƒ∞lk durumu kontrol et
    _checkConnectivity();
    
    // Not: NetworkChecker'ƒ±n stream'ini dinleyebiliriz ama ≈üimdilik manuel kontrol yeterli
  }

  // üÜï Baƒülantƒ± durumunu kontrol et
  Future<void> _checkConnectivity() async {
    try {
      final cacheInfo = await _productRepository.getCacheInfo();
      final wasOffline = _isOffline;
      _isOffline = !(cacheInfo['isOnline'] as bool);
      
      // Offline'dan online'a ge√ßtiyse otomatik yenile
      if (wasOffline && !_isOffline && _products.isNotEmpty) {
        print('üîÑ Online\'a ge√ßildi, √ºr√ºnler yenileniyor...');
        await loadProducts(forceRefresh: true);
      }
    } catch (e) {
      print('‚ùå Connectivity check error: $e');
    }
  }

  // √úr√ºnleri y√ºkle
  Future<void> loadProducts({bool forceRefresh = false}) async {
    if (_isLoading) return;

    _isLoading = true;
    _errorMessage = null;
    _currentPage = 1;
    _hasMore = true;
    notifyListeners();

    try {
      // Baƒülantƒ± durumunu kontrol et
      await _checkConnectivity();

      final fetchedProducts = await _productRepository.fetchProducts(
        page: _currentPage,
        limit: _pageSize,
        forceRefresh: forceRefresh,
      );

      _products = fetchedProducts;
      _applyFilters();
      _hasMore = fetchedProducts.length >= _pageSize;

      print('‚úÖ ${fetchedProducts.length} √ºr√ºn y√ºklendi');
      
      // Ba≈üarƒ±lƒ±ysa offline durumunu kaldƒ±r
      _isOffline = false;
    } catch (e) {
      _errorMessage = e.toString();
      print('‚ùå loadProducts hatasƒ±: $e');
      
      // ƒ∞nternet hatasƒ± mƒ± kontrol et
      if (_errorMessage?.contains('ƒ∞nternet') == true || 
          _errorMessage?.contains('baƒülantƒ±') == true) {
        _isOffline = true;
      }
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Daha fazla √ºr√ºn y√ºkle (Pagination)
  Future<void> loadMoreProducts() async {
    if (_isLoadingMore || !_hasMore || _isLoading || _isOffline) return;
    if (_selectedCategory != null || _searchQuery.isNotEmpty) return;

    _isLoadingMore = true;
    notifyListeners();

    try {
      _currentPage++;
      
      final moreProducts = await _productRepository.fetchProducts(
        page: _currentPage,
        limit: _pageSize,
      );

      if (moreProducts.isEmpty || moreProducts.length < _pageSize) {
        _hasMore = false;
      }

      _products.addAll(moreProducts);
      _applyFilters();

      print('‚úÖ ${moreProducts.length} √ºr√ºn daha y√ºklendi (Sayfa $_currentPage)');
    } catch (e) {
      _errorMessage = e.toString();
      _currentPage--;
      print('‚ùå loadMoreProducts hatasƒ±: $e');
    } finally {
      _isLoadingMore = false;
      notifyListeners();
    }
  }

  // Kategoriye g√∂re filtrele
  Future<void> filterByCategory(String? category) async {
    if (_selectedCategory == category) return;

    _selectedCategory = category;
    _searchQuery = '';
    _currentPage = 1;
    _hasMore = true;

    if (category == null || category.isEmpty) {
      _applyFilters();
      notifyListeners();
      return;
    }

    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      final filteredProducts = await _productRepository.fetchProductsByCategory(category);
      _filteredProducts = filteredProducts;
      
      print('‚úÖ ${filteredProducts.length} √ºr√ºn filtrelendi (Kategori: $category)');
    } catch (e) {
      _errorMessage = e.toString();
      print('‚ùå filterByCategory hatasƒ±: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Arama (Debounce ile)
  void searchProducts(String query) {
    _searchQuery = query;

    _debounceTimer?.cancel();
    _debounceTimer = Timer(const Duration(milliseconds: 500), () {
      _performSearch();
    });
  }

  Future<void> _performSearch() async {
    if (_searchQuery.isEmpty) {
      _selectedCategory = null;
      _applyFilters();
      notifyListeners();
      return;
    }

    // LOCAL ARAMA (Client-side filtering)
    _selectedCategory = null;
    
    final query = _searchQuery.toLowerCase().trim();
    
    _filteredProducts = _products.where((product) {
      final stokAdi = product.stokAdi.toLowerCase();
      final stokKodu = product.stokKodu.toLowerCase();
      final kategori = product.kategori.toLowerCase();
      
      return stokAdi.contains(query) || 
             stokKodu.contains(query) || 
             kategori.contains(query);
    }).toList();
    
    print('üîç ${_filteredProducts.length} √ºr√ºn bulundu (Arama: $_searchQuery)');
    notifyListeners();
  }

  // Filtreleri uygula (local filtreleme)
  void _applyFilters() {
    if (_selectedCategory == null && _searchQuery.isEmpty) {
      _filteredProducts = [];
      return;
    }

    _filteredProducts = _products.where((product) {
      bool matchesCategory = _selectedCategory == null || 
          product.kategori.toLowerCase().contains(_selectedCategory!.toLowerCase());
      
      bool matchesSearch = _searchQuery.isEmpty ||
          product.stokAdi.toLowerCase().contains(_searchQuery.toLowerCase()) ||
          product.stokKodu.toLowerCase().contains(_searchQuery.toLowerCase());

      return matchesCategory && matchesSearch;
    }).toList();
  }

  // Kategorileri al (unique)
  List<String> getCategories() {
    final categories = _products.map((p) => p.kategori).toSet().toList();
    categories.sort();
    return categories;
  }

  // Tek √ºr√ºn getir
  Future<ProductModel?> getProductById(String productId) async {
    try {
      final localProduct = _products.firstWhere(
        (p) => p.id == productId,
        orElse: () => _filteredProducts.firstWhere(
          (p) => p.id == productId,
          orElse: () => throw Exception('Not found'),
        ),
      );
      return localProduct;
    } catch (e) {
      try {
        return await _productRepository.fetchProductById(productId);
      } catch (e) {
        print('‚ùå getProductById hatasƒ±: $e');
        return null;
      }
    }
  }

  // Cache temizle ve yeniden y√ºkle
  Future<void> refreshProducts() async {
    await _productRepository.clearCache();
    await loadProducts(forceRefresh: true);
  }

  // üÜï Cache bilgisini al
  Future<Map<String, dynamic>> getCacheInfo() async {
    return await _productRepository.getCacheInfo();
  }

  // üÜï Manuel baƒülantƒ± kontrol√º (Pull-to-refresh i√ßin)
  Future<void> checkConnectivityAndRefresh() async {
    await _checkConnectivity();
    if (!_isOffline) {
      await refreshProducts();
    }
    notifyListeners();
  }

  // Reset
  void reset() {
    _products = [];
    _filteredProducts = [];
    _isLoading = false;
    _isLoadingMore = false;
    _isOffline = false;
    _errorMessage = null;
    _selectedCategory = null;
    _searchQuery = '';
    _currentPage = 1;
    _hasMore = true;
    _debounceTimer?.cancel();
    notifyListeners();
  }

  // Kategorileri d√∂nd√ºr (CategoryProvider i√ßin)
  List<String> getAllCategories() {
    final categories = _products.map((p) => p.kategori).toSet().toList();
    categories.sort();
    return categories;
  }

  // Kategori bazlƒ± √ºr√ºn sayƒ±sƒ±
  Map<String, int> getCategoryProductCount() {
    final Map<String, int> count = {};
    for (var product in _products) {
      count[product.kategori] = (count[product.kategori] ?? 0) + 1;
    }
    return count;
  }

  @override
  void dispose() {
    _debounceTimer?.cancel();
    _connectivitySubscription?.cancel();
    super.dispose();
  }
}